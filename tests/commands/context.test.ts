import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { afterEach, describe, expect, it, vi } from "vitest";
import { generateContextFile, runContextCommand } from "../../src/commands/context.js";
import type { RecallCommandResult, StoredEntry } from "../../src/types.js";

const tempDirs: string[] = [];

async function makeTempDir(): Promise<string> {
  const dir = await fs.mkdtemp(path.join(os.tmpdir(), "agenr-context-test-"));
  tempDirs.push(dir);
  return dir;
}

function makeEntry(overrides: Partial<StoredEntry> = {}): StoredEntry {
  return {
    id: "entry-1",
    type: "fact",
    subject: "Subject",
    content: "Content",
    importance: 8,
    expiry: "temporary",
    scope: "private",
    tags: [],
    source: { file: "source.jsonl", context: "test" },
    embedding: [0.1, 0.2, 0.3],
    created_at: "2026-02-14T00:00:00.000Z",
    updated_at: "2026-02-14T00:00:00.000Z",
    recall_count: 0,
    confirmations: 0,
    contradictions: 0,
    ...overrides,
  };
}

function makeResult(category: RecallCommandResult["category"], overrides: Partial<StoredEntry> = {}): RecallCommandResult {
  return {
    entry: makeEntry(overrides),
    score: 0.8,
    scores: { vector: 0, recency: 0, importance: 0, recall: 0, freshness: 1, todoPenalty: 1, fts: 0, spacing: 1 },
    category,
  };
}

afterEach(async () => {
  for (const dir of tempDirs) {
    await fs.rm(dir, { recursive: true, force: true });
  }
  tempDirs.length = 0;
  vi.restoreAllMocks();
});

describe("context command", () => {
  it("generates markdown with correct category sections and formatting", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.md");

    const sessionStartRecallFn = vi.fn(async () => ({
      results: [
        makeResult("core", { id: "c1", type: "fact", subject: "Core", content: "Core content", expiry: "core" }),
        makeResult("recent", { id: "r1", type: "event", subject: "Recent", content: "Recent content" }),
        makeResult("active", { id: "a1", type: "todo", subject: "Active", content: "Active todo" }),
        makeResult("preferences", { id: "p1", type: "preference", subject: "Pref", content: "Pref content" }),
      ],
      budgetUsed: 123,
    }));

    await generateContextFile({} as any, "", outPath, { budget: 2000, limit: 10, json: false, now: new Date("2026-02-17T00:00:00.000Z") }, { sessionStartRecallFn });

    const content = await fs.readFile(outPath, "utf8");
    expect(content).toContain("# Agenr Context");
    expect(content).toContain("<!-- Generated by agenr context | DO NOT EDIT -->");
    expect(content).toContain("<!-- refreshed: 2026-02-17T00:00:00.000Z -->");
    expect(content).toContain("## Core");
    expect(content).toContain("## Recent");
    expect(content).toContain("## Active");
    expect(content).toContain("## Preferences");
    expect(content).toContain("- [fact] Core: Core content");
    expect(content).toContain("- [event] Recent: Recent content");
    expect(content).toContain("- [todo] Active: Active todo");
    expect(content).toContain("- [preference] Pref: Pref content");
  });

  it("skips empty categories in markdown output", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.md");

    const sessionStartRecallFn = vi.fn(async () => ({
      results: [makeResult("core", { id: "c1", subject: "Only core", content: "Identity", expiry: "core" })],
      budgetUsed: 0,
    }));

    await generateContextFile({} as any, "", outPath, { budget: 2000, limit: 10, json: false }, { sessionStartRecallFn, nowFn: () => new Date("2026-02-17T00:00:00.000Z") });

    const content = await fs.readFile(outPath, "utf8");
    expect(content).toContain("## Core");
    expect(content).not.toContain("## Recent");
    expect(content).not.toContain("## Active");
    expect(content).not.toContain("## Preferences");
  });

  it("truncates long content at 200 chars", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.md");
    const longContent = "x".repeat(500);

    const sessionStartRecallFn = vi.fn(async () => ({
      results: [makeResult("recent", { id: "r1", type: "event", subject: "Long", content: longContent })],
      budgetUsed: 0,
    }));

    await generateContextFile({} as any, "", outPath, { budget: 2000, limit: 10, json: false }, { sessionStartRecallFn, nowFn: () => new Date("2026-02-17T00:00:00.000Z") });

    const content = await fs.readFile(outPath, "utf8");
    const line = content.split("\n").find((row) => row.startsWith("- [event]")) ?? "";
    expect(content).toContain("## Recent");
    expect(line.endsWith("...")).toBe(true);
    expect(line.length).toBeLessThanOrEqual("- [event] Long: ".length + 200);
  });

  it("writes via temp file then rename (atomic write) and keeps tmp in same directory", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.md");

    const writeCalls: string[] = [];
    const renameCalls: Array<{ from: string; to: string }> = [];
    const mkdirCalls: string[] = [];

    const sessionStartRecallFn = vi.fn(async () => ({
      results: [makeResult("core", { id: "c1", subject: "Core", content: "Core", expiry: "core" })],
      budgetUsed: 0,
    }));

    await generateContextFile(
      {} as any,
      "",
      outPath,
      { budget: 2000, limit: 10, json: false, now: new Date("2026-02-17T00:00:00.000Z") },
      {
        sessionStartRecallFn,
        mkdirFn: vi.fn(async (p: any, _opts: any) => {
          mkdirCalls.push(String(p));
          await fs.mkdir(String(p), { recursive: true });
        }) as any,
        writeFileFn: vi.fn(async (p: any, data: any, opts: any) => {
          writeCalls.push(String(p));
          await fs.writeFile(String(p), data, opts);
        }) as any,
        renameFn: vi.fn(async (from: any, to: any) => {
          renameCalls.push({ from: String(from), to: String(to) });
          await fs.rename(String(from), String(to));
        }) as any,
      },
    );

    expect(mkdirCalls.some((p) => p === dir)).toBe(true);
    expect(writeCalls.length).toBe(1);
    expect(renameCalls.length).toBe(1);
    const tmpPath = writeCalls[0]!;
    expect(path.dirname(tmpPath)).toBe(path.dirname(outPath));
    expect(tmpPath).toContain(`.tmp.${process.pid}.`);
    expect(renameCalls[0]).toEqual({ from: tmpPath, to: outPath });
  });

  it("respects --budget and --limit flags (passes them into session-start recall)", async () => {
    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));
    const result = await runContextCommand(
      { output: "/tmp/agenr-context-test.md", budget: "123", limit: "7", quiet: true },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: vi.fn(async () => undefined) as any,
        writeFileFn: vi.fn(async () => undefined) as any,
        renameFn: vi.fn(async () => undefined) as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    expect(result.exitCode).toBe(0);
    expect(sessionStartRecallFn).toHaveBeenCalledTimes(1);
    const call = (sessionStartRecallFn.mock.calls as any[][])[0] as any[] | undefined;
    const options = call?.[1];
    expect(options?.budget).toBe(123);
    expect(options?.coreCandidateLimit).toBe(7);
  });

  it("passes --platform into session-start recall when provided", async () => {
    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));
    await runContextCommand(
      { output: "/tmp/agenr-context-test.md", quiet: true, platform: "codex" },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: vi.fn(async () => undefined) as any,
        writeFileFn: vi.fn(async () => undefined) as any,
        renameFn: vi.fn(async () => undefined) as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    const call = (sessionStartRecallFn.mock.calls as any[][])[0] as any[] | undefined;
    expect(call?.[1]?.query?.platform).toBe("codex");
  });

  it("passes --project into session-start recall when provided", async () => {
    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));
    await runContextCommand(
      { output: "/tmp/agenr-context-test.md", quiet: true, project: "agenr,openclaw" },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: vi.fn(async () => undefined) as any,
        writeFileFn: vi.fn(async () => undefined) as any,
        renameFn: vi.fn(async () => undefined) as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    const call = (sessionStartRecallFn.mock.calls as any[][])[0] as any[] | undefined;
    expect(call?.[1]?.query?.project).toEqual(["agenr", "openclaw"]);
  });

  it("sets projectStrict when --strict is used with --project", async () => {
    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));
    await runContextCommand(
      { output: "/tmp/agenr-context-test.md", quiet: true, project: "agenr", strict: true },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: vi.fn(async () => undefined) as any,
        writeFileFn: vi.fn(async () => undefined) as any,
        renameFn: vi.fn(async () => undefined) as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    const call = (sessionStartRecallFn.mock.calls as any[][])[0] as any[] | undefined;
    expect(call?.[1]?.query?.projectStrict).toBe(true);
  });

  it("works with an empty DB (no entries, no error)", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.md");

    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));
    const result = await runContextCommand(
      { output: outPath, quiet: true },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: fs.mkdir as any,
        writeFileFn: fs.writeFile as any,
        renameFn: fs.rename as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    expect(result.exitCode).toBe(0);
    const content = await fs.readFile(outPath, "utf8");
    expect(content).toContain("# Agenr Context");
    expect(content).not.toContain("## Core");
  });

  it("outputs JSON in --json mode (stdout + file) and does not emit markdown", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.json");
    const stdoutSpy = vi.spyOn(process.stdout, "write").mockImplementation(() => true);

    const sessionStartRecallFn = vi.fn(async () => ({
      results: [makeResult("recent", { id: "r1", type: "event", subject: "Recent", content: "Hello" })],
      budgetUsed: 0,
    }));

    const result = await runContextCommand(
      { output: outPath, json: true, quiet: true },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: fs.mkdir as any,
        writeFileFn: fs.writeFile as any,
        renameFn: fs.rename as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    expect(result.exitCode).toBe(0);
    const stdout = stdoutSpy.mock.calls.map((call) => String(call[0])).join("");
    const parsed = JSON.parse(stdout) as { refreshed_at: string; categories: Record<string, unknown[]> };
    expect(parsed.refreshed_at).toBe("2026-02-17T00:00:00.000Z");
    expect(Array.isArray(parsed.categories.recent)).toBe(true);

    const fileContent = await fs.readFile(outPath, "utf8");
    expect(fileContent.trim().startsWith("{")).toBe(true);
    expect(fileContent).not.toContain("# Agenr Context");
  });

  it("--output resolves ~ to home directory", async () => {
    const mkdirFn = vi.fn(async () => undefined);
    const writeFileFn = vi.fn(async () => undefined);
    const renameFn = vi.fn(async () => undefined);

    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));
    const result = await runContextCommand(
      { output: "~/.agenr/CONTEXT.md", quiet: true },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: mkdirFn as any,
        writeFileFn: writeFileFn as any,
        renameFn: renameFn as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    expect(result.exitCode).toBe(0);
    expect(mkdirFn).toHaveBeenCalledTimes(1);
    const mkdirPath = String((mkdirFn.mock.calls as any[][])[0]?.[0]);
    expect(mkdirPath.startsWith(os.homedir())).toBe(true);
  });

  it("quiet mode suppresses stderr output (even on error)", async () => {
    const stderrSpy = vi.spyOn(process.stderr, "write").mockImplementation(() => true);
    const sessionStartRecallFn = vi.fn(async () => {
      throw new Error("SQLITE_BUSY: database is locked");
    });

    const result = await runContextCommand(
      { output: "/tmp/agenr-context-test.md", quiet: true },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: vi.fn(async () => undefined) as any,
        writeFileFn: vi.fn(async () => undefined) as any,
        renameFn: vi.fn(async () => undefined) as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    expect(result.exitCode).toBe(1);
    expect(stderrSpy).not.toHaveBeenCalled();
  });

  it("permission denied on output path returns a clear error", async () => {
    const stderrSpy = vi.spyOn(process.stderr, "write").mockImplementation(() => true);
    const sessionStartRecallFn = vi.fn(async () => ({ results: [], budgetUsed: 0 }));

    const result = await runContextCommand(
      { output: "/root/CONTEXT.md", quiet: false },
      {
        readConfigFn: vi.fn(() => ({ db: { path: ":memory:" } })),
        getDbFn: vi.fn(() => ({}) as any),
        initDbFn: vi.fn(async () => undefined),
        closeDbFn: vi.fn(() => undefined),
        sessionStartRecallFn: sessionStartRecallFn as any,
        mkdirFn: vi.fn(async () => undefined) as any,
        writeFileFn: vi.fn(async () => {
          throw new Error("EACCES: permission denied");
        }) as any,
        renameFn: vi.fn(async () => undefined) as any,
        nowFn: () => new Date("2026-02-17T00:00:00.000Z"),
      },
    );

    expect(result.exitCode).toBe(1);
    expect(result.error?.toLowerCase()).toContain("permission denied");
    expect(stderrSpy).toHaveBeenCalled();
  });

  it("concurrent writes do not corrupt the output file", async () => {
    const dir = await makeTempDir();
    const outPath = path.join(dir, "CONTEXT.md");

    const call1 = generateContextFile(
      {} as any,
      "",
      outPath,
      { budget: 2000, limit: 10, json: false, now: new Date("2026-02-17T00:00:00.000Z") },
      {
        sessionStartRecallFn: vi.fn(async () => ({
          results: [makeResult("recent", { id: "r1", type: "event", subject: "A", content: "Alpha" })],
          budgetUsed: 0,
        })),
      },
    );

    const call2 = generateContextFile(
      {} as any,
      "",
      outPath,
      { budget: 2000, limit: 10, json: false, now: new Date("2026-02-17T00:00:01.000Z") },
      {
        sessionStartRecallFn: vi.fn(async () => ({
          results: [makeResult("recent", { id: "r2", type: "event", subject: "B", content: "Beta" })],
          budgetUsed: 0,
        })),
      },
    );

    const [r1, r2] = await Promise.all([call1, call2]);
    const final = await fs.readFile(outPath, "utf8");

    expect([r1.content, r2.content]).toContain(final);
  });
});
