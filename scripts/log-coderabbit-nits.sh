#!/usr/bin/env bash
# log-coderabbit-nits.sh
# Extracts nitpick comments from the latest CodeRabbit review on a PR
# and files them as a single GitHub issue so you can merge and move on.
#
# Usage:
#   ./scripts/log-coderabbit-nits.sh <pr-number>
#
# Requirements:
#   - gh CLI authenticated
#   - Run from the repo root

set -euo pipefail

PR="${1:-}"
if [[ -z "$PR" ]]; then
  echo "Usage: $0 <pr-number>" >&2
  exit 1
fi

if ! git rev-parse --show-toplevel &>/dev/null; then
  echo "Error: must be run from inside a git repository" >&2
  exit 1
fi

cd "$(git rev-parse --show-toplevel)"

echo "Fetching latest CodeRabbit review for PR #${PR}..." >&2

PR_TITLE="$(gh pr view "$PR" --json title --jq '.title')"
PR_URL="$(gh pr view "$PR" --json url --jq '.url')"

REVIEW_BODY="$(gh pr view "$PR" --json reviews --jq '
  .reviews
  | map(select(.author.login | test("coderabbitai"; "i")))
  | last
  | .body
  // empty
')"

if [[ -z "$REVIEW_BODY" ]]; then
  echo "Error: no CodeRabbit review found on PR #${PR}" >&2
  exit 1
fi

# Write review to temp file to avoid bash variable/pipe encoding issues
TMPFILE="$(mktemp /tmp/cr-review-XXXXX.txt)"
trap 'rm -f "$TMPFILE"' EXIT
printf '%s' "$REVIEW_BODY" > "$TMPFILE"

# Extract the nitpick section - everything inside the <details> block for nitpicks
NITS="$(python3 - "$TMPFILE" <<'PYEOF'
import sys, re

with open(sys.argv[1]) as f:
    content = f.read()

# CodeRabbit format:
# <details>
# <summary>ðŸ§¹ Nitpick comments (N)</summary><blockquote>
#   ... nested details per file ...
# </blockquote></details>

# Find the start of the nitpick block
start_match = re.search(r'<summary>[^<]*Nitpick comments[^<]*</summary>', content, re.IGNORECASE)
if not start_match:
    print("")
    sys.exit(0)

# From that point, find the opening <blockquote> and walk to the matching close
rest = content[start_match.end():]
bq_start = rest.find('<blockquote>')
if bq_start == -1:
    print("")
    sys.exit(0)

# Walk forward counting <blockquote>/<blockquote> nesting to find the closing tag
inner = rest[bq_start + len('<blockquote>'):]
depth = 1
pos = 0
while depth > 0 and pos < len(inner):
    open_pos = inner.find('<blockquote>', pos)
    close_pos = inner.find('</blockquote>', pos)
    if close_pos == -1:
        break
    if open_pos != -1 and open_pos < close_pos:
        depth += 1
        pos = open_pos + len('<blockquote>')
    else:
        depth -= 1
        if depth == 0:
            print(inner[:close_pos].strip())
        else:
            pos = close_pos + len('</blockquote>')

PYEOF
)"

if [[ -z "$NITS" ]]; then
  echo "No nitpick comments found in the latest CodeRabbit review for PR #${PR}." >&2
  exit 0
fi

# Count rough number of nits for the issue title
NIT_COUNT="$(echo "$NITS" | grep -c "^_\|^>\|^In \`\|^-\s" 2>/dev/null || echo "several")"

ISSUE_BODY="## CodeRabbit nitpicks from PR #${PR}

These were logged as non-blocking issues to allow PR #${PR} to merge.
Original PR: ${PR_URL}

---

${NITS}

---
*Auto-generated by \`scripts/log-coderabbit-nits.sh ${PR}\`*"

echo "Creating issue..." >&2

# Ensure chore label exists
if ! gh label list --json name --jq '.[].name' | grep -q '^chore$'; then
  gh label create chore --description "Maintenance and housekeeping" --color "#e4e669" --force 2>/dev/null || true
fi

ISSUE_URL="$(gh issue create \
  --title "chore: CodeRabbit nitpicks from PR #${PR} (${PR_TITLE})" \
  --body "$ISSUE_BODY" \
  --label "chore" \
  2>&1 | tail -1)"

echo "Issue created: ${ISSUE_URL}" >&2
echo "$ISSUE_URL"
