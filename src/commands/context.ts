import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import * as clack from "@clack/prompts";
import type { Client } from "@libsql/client";
import { readConfig } from "../config.js";
import { closeDb, getDb, initDb } from "../db/client.js";
import { sessionStartRecall } from "../db/session-start.js";
import { resolveEmbeddingApiKey } from "../embeddings/client.js";
import { normalizeKnowledgePlatform } from "../platform.js";
import { hasAnyProjectParts, parseProjectList } from "../project.js";
import { KNOWLEDGE_PLATFORMS } from "../types.js";
import type { RecallCommandResult, RecallQuery } from "../types.js";
import type { KnowledgePlatform } from "../types.js";

const DEFAULT_OUTPUT_PATH = "~/.agenr/CONTEXT.md";
const DEFAULT_BUDGET = 2000;
const DEFAULT_LIMIT = 10;
const MAX_CONTENT_CHARS = 200;

export interface ContextCommandOptions {
  output?: string;
  budget?: number | string;
  limit?: number | string;
  platform?: string;
  project?: string | string[];
  excludeProject?: string | string[];
  strict?: boolean;
  db?: string;
  json?: boolean;
  quiet?: boolean;
}

export interface ContextCommandDeps {
  readConfigFn: typeof readConfig;
  resolveEmbeddingApiKeyFn: typeof resolveEmbeddingApiKey;
  getDbFn: typeof getDb;
  initDbFn: typeof initDb;
  closeDbFn: typeof closeDb;
  sessionStartRecallFn: typeof sessionStartRecall;
  writeFileFn: typeof fs.writeFile;
  renameFn: typeof fs.rename;
  mkdirFn: typeof fs.mkdir;
  nowFn: () => Date;
}

export interface ContextLineItem {
  type: string;
  subject: string;
  content: string;
}

export interface ContextJsonOutput {
  refreshed_at: string;
  categories: {
    core: ContextLineItem[];
    recent: ContextLineItem[];
    active: ContextLineItem[];
    preferences: ContextLineItem[];
  };
}

export interface ContextCommandResult {
  exitCode: number;
  outputPath: string;
  refreshedAt?: string;
  error?: string;
}

function parsePositiveInt(value: number | string | undefined, fallback: number, label: string): number {
  if (value === undefined || value === null || String(value).trim() === "") {
    return fallback;
  }

  const parsed = typeof value === "number" ? value : Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    throw new Error(`${label} must be a positive number.`);
  }
  return Math.floor(parsed);
}

function resolveTildePath(inputPath: string): string {
  return inputPath.replace(/^~(?=$|\/)/, os.homedir());
}

function truncateContent(content: string): string {
  if (content.length <= MAX_CONTENT_CHARS) {
    return content;
  }
  const sliceLength = Math.max(0, MAX_CONTENT_CHARS - 3);
  return `${content.slice(0, sliceLength)}...`;
}

function toLineItem(result: RecallCommandResult): ContextLineItem {
  return {
    type: result.entry.type,
    subject: result.entry.subject,
    content: truncateContent(result.entry.content),
  };
}

function groupAndLimit(results: RecallCommandResult[], limit: number): ContextJsonOutput["categories"] {
  const buckets: ContextJsonOutput["categories"] = {
    core: [],
    recent: [],
    active: [],
    preferences: [],
  };

  for (const result of results) {
    const category = result.category ?? "recent";
    if (category === "core") {
      buckets.core.push(toLineItem(result));
    } else if (category === "recent") {
      buckets.recent.push(toLineItem(result));
    } else if (category === "active") {
      buckets.active.push(toLineItem(result));
    } else if (category === "preferences") {
      buckets.preferences.push(toLineItem(result));
    }
  }

  return {
    core: buckets.core.slice(0, limit),
    recent: buckets.recent.slice(0, limit),
    active: buckets.active.slice(0, limit),
    preferences: buckets.preferences.slice(0, limit),
  };
}

function formatMarkdown(output: ContextJsonOutput): string {
  const lines: string[] = [
    "# Agenr Context",
    "<!-- Generated by agenr context | DO NOT EDIT -->",
    `<!-- refreshed: ${output.refreshed_at} -->`,
    "",
  ];

  const sections: Array<{ title: string; key: keyof ContextJsonOutput["categories"] }> = [
    { title: "Core", key: "core" },
    { title: "Recent", key: "recent" },
    { title: "Active", key: "active" },
    { title: "Preferences", key: "preferences" },
  ];

  for (const section of sections) {
    const items = output.categories[section.key];
    if (items.length === 0) {
      continue;
    }

    lines.push(`## ${section.title}`);
    for (const item of items) {
      lines.push(`- [${item.type}] ${item.subject}: ${item.content}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

export interface GenerateContextFileOptions {
  budget: number;
  limit: number;
  json: boolean;
  now?: Date;
  platform?: KnowledgePlatform;
  project?: string | string[];
  excludeProject?: string | string[];
  projectStrict?: boolean;
}

export async function generateContextFile(
  db: Client,
  apiKey: string,
  outputPath: string,
  options: GenerateContextFileOptions,
  deps?: Partial<Pick<ContextCommandDeps, "sessionStartRecallFn" | "writeFileFn" | "renameFn" | "mkdirFn" | "nowFn">>,
): Promise<{ outputPath: string; refreshedAt: string; payload: ContextJsonOutput; content: string }> {
  const resolvedDeps = {
    sessionStartRecallFn: deps?.sessionStartRecallFn ?? sessionStartRecall,
    writeFileFn: deps?.writeFileFn ?? fs.writeFile,
    renameFn: deps?.renameFn ?? fs.rename,
    mkdirFn: deps?.mkdirFn ?? fs.mkdir,
    nowFn: deps?.nowFn ?? (() => new Date()),
  };

  const refreshedAt = (options.now ?? resolvedDeps.nowFn()).toISOString();
  const limit = parsePositiveInt(options.limit, DEFAULT_LIMIT, "--limit");
  const budget = parsePositiveInt(options.budget, DEFAULT_BUDGET, "--budget");

  const query: RecallQuery = {
    context: "session-start",
    noUpdate: true,
    scope: "private",
    budget,
    platform: options.platform,
    project: options.project,
    excludeProject: options.excludeProject,
    projectStrict: options.projectStrict,
  };

  const grouped = await resolvedDeps.sessionStartRecallFn(db, {
    query,
    apiKey,
    budget,
    nonCoreLimit: limit * 3,
    coreCandidateLimit: limit,
  });

  const categories = groupAndLimit(grouped.results, limit);
  const payload: ContextJsonOutput = {
    refreshed_at: refreshedAt,
    categories,
  };

  const content = options.json ? `${JSON.stringify(payload, null, 2)}\n` : formatMarkdown(payload);

  const resolvedOutputPath = path.resolve(resolveTildePath(outputPath));
  await resolvedDeps.mkdirFn(path.dirname(resolvedOutputPath), { recursive: true });

  // Keep the temp file in the same directory to avoid EXDEV rename failures across filesystems.
  const tmpPath = `${resolvedOutputPath}.tmp.${process.pid}.${Math.random().toString(16).slice(2)}`;
  await resolvedDeps.writeFileFn(tmpPath, content, { encoding: "utf8", mode: 0o600 });
  await resolvedDeps.renameFn(tmpPath, resolvedOutputPath);

  return { outputPath: resolvedOutputPath, refreshedAt, payload, content };
}

export async function runContextCommand(
  options: ContextCommandOptions,
  deps?: Partial<ContextCommandDeps>,
): Promise<ContextCommandResult> {
  const resolvedDeps: ContextCommandDeps = {
    readConfigFn: deps?.readConfigFn ?? readConfig,
    resolveEmbeddingApiKeyFn: deps?.resolveEmbeddingApiKeyFn ?? resolveEmbeddingApiKey,
    getDbFn: deps?.getDbFn ?? getDb,
    initDbFn: deps?.initDbFn ?? initDb,
    closeDbFn: deps?.closeDbFn ?? closeDb,
    sessionStartRecallFn: deps?.sessionStartRecallFn ?? sessionStartRecall,
    writeFileFn: deps?.writeFileFn ?? fs.writeFile,
    renameFn: deps?.renameFn ?? fs.rename,
    mkdirFn: deps?.mkdirFn ?? fs.mkdir,
    nowFn: deps?.nowFn ?? (() => new Date()),
  };

  const outputPath = resolveTildePath((options.output ?? DEFAULT_OUTPUT_PATH).trim() || DEFAULT_OUTPUT_PATH);
  const budget = parsePositiveInt(options.budget, DEFAULT_BUDGET, "--budget");
  const limit = parsePositiveInt(options.limit, DEFAULT_LIMIT, "--limit");
  const json = options.json === true;
  const platformRaw = options.platform?.trim();
  const platform = platformRaw ? normalizeKnowledgePlatform(platformRaw) : null;
  if (platformRaw && !platform) {
    throw new Error(`--platform must be one of: ${KNOWLEDGE_PLATFORMS.join(", ")}`);
  }

  const parsedProject = parseProjectList(options.project);
  const parsedExcludeProject = parseProjectList(options.excludeProject);
  if (hasAnyProjectParts(options.project) && parsedProject.length === 0) {
    throw new Error("--project must be a non-empty string (or comma-separated list).");
  }
  if (hasAnyProjectParts(options.excludeProject) && parsedExcludeProject.length === 0) {
    throw new Error("--exclude-project must be a non-empty string (or comma-separated list).");
  }

  const project = parsedProject.length > 0 ? parsedProject : undefined;
  const excludeProject = parsedExcludeProject.length > 0 ? parsedExcludeProject : undefined;
  const projectStrict = options.strict === true && Boolean(project && project.length > 0);

  // Suppress clack output when explicitly quiet, or when stderr is not a TTY.
  const suppressClack = options.quiet === true || !process.stderr.isTTY;
  const suppressStderr = options.quiet === true;
  const clackOutput = suppressClack ? null : { output: process.stderr };

  const config = resolvedDeps.readConfigFn(process.env);
  const dbPath = options.db?.trim() || config?.db?.path;
  const db = resolvedDeps.getDbFn(dbPath);

  try {
    if (clackOutput) {
      clack.intro("agenr context", clackOutput);
    }

    await resolvedDeps.initDbFn(db);

    // Session-start recall without query text never reaches the embedding API.
    // apiKey is accepted for signature compatibility but may be empty.
    let apiKey = "";
    try {
      apiKey = resolvedDeps.resolveEmbeddingApiKeyFn(config, process.env);
    } catch {
      apiKey = "";
    }

    const generated = await generateContextFile(
      db,
      apiKey,
      outputPath,
      {
        budget,
        limit,
        json,
        now: resolvedDeps.nowFn(),
        platform: platform ?? undefined,
        project,
        excludeProject,
        projectStrict: projectStrict ? true : undefined,
      },
      {
        sessionStartRecallFn: resolvedDeps.sessionStartRecallFn,
        writeFileFn: resolvedDeps.writeFileFn,
        renameFn: resolvedDeps.renameFn,
        mkdirFn: resolvedDeps.mkdirFn,
        nowFn: resolvedDeps.nowFn,
      },
    );

    if (json) {
      process.stdout.write(`${JSON.stringify(generated.payload, null, 2)}\n`);
    }

    if (clackOutput) {
      clack.outro(`Wrote ${generated.outputPath}`, clackOutput);
    }

    return { exitCode: 0, outputPath: generated.outputPath, refreshedAt: generated.refreshedAt };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    if (!suppressStderr) {
      process.stderr.write(`${message}\n`);
    }
    return { exitCode: 1, outputPath: path.resolve(outputPath), error: message };
  } finally {
    resolvedDeps.closeDbFn(db);
  }
}
