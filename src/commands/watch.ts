import fs from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import * as clack from "@clack/prompts";
import { readConfig } from "../config.js";
import { warnIfLocked } from "../db/lockfile.js";
import { deduplicateEntries } from "../dedup.js";
import { closeDb, getDb, initDb } from "../db/client.js";
import { mapStoredEntry, scoreEntryWithBreakdown } from "../db/recall.js";
import { estimateEntryTokens } from "../db/session-start.js";
import { storeEntries } from "../db/store.js";
import { resolveEmbeddingApiKey } from "../embeddings/client.js";
import { extractKnowledgeFromChunks } from "../extractor.js";
import { createLlmClient } from "../llm/client.js";
import { parseTranscriptFile } from "../parser.js";
import type { WatchOptions } from "../types.js";
import { banner, formatLabel, formatWarn } from "../ui.js";
import { generateContextFile } from "./context.js";
import { detectWatchPlatform, getResolver, type WatchPlatform } from "../watch/resolvers/index.js";
import { getDefaultPlatformDir } from "../watch/platform-defaults.js";
import { getFileState, loadWatchState, saveWatchState } from "../watch/state.js";
import { readFileFromOffset, runWatcher } from "../watch/watcher.js";
import { installSignalHandlers, isShutdownRequested } from "../shutdown.js";
import type { RecallResult, StoredEntry } from "../types.js";

function formatBytes(value: number): string {
  return value.toLocaleString("en-US");
}

function formatClock(value: Date): string {
  return value.toTimeString().slice(0, 8);
}

function formatInterval(intervalMs: number): string {
  const seconds = Math.floor(intervalMs / 1000);
  if (seconds % 60 === 0) {
    return `${Math.floor(seconds / 60)}m`;
  }
  return `${seconds}s`;
}

function formatDuration(durationMs: number): string {
  const totalSeconds = Math.max(0, Math.floor(durationMs / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  if (minutes === 0) {
    return `${seconds}s`;
  }
  return `${minutes}m ${seconds}s`;
}

function parsePositiveInt(value: number | string | undefined, fallback: number, label: string): number {
  if (value === undefined || value === null || String(value).trim().length === 0) {
    return fallback;
  }
  const parsed = typeof value === "number" ? value : Number(value);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    throw new Error(`${label} must be a positive number.`);
  }
  return Math.floor(parsed);
}

function formatSwitchLabel(filePath: string): string {
  return path.resolve(filePath);
}

function truncateContextContent(content: string, max = 200): string {
  if (content.length <= max) {
    return content;
  }
  return `${content.slice(0, Math.max(0, max - 3))}...`;
}

const ENTRY_SELECT_COLUMNS = `
        id, type, subject, canonical_key, content, importance, expiry, scope,
        platform, project, source_file, source_context, embedding,
        created_at, updated_at, last_recalled_at, recall_count, confirmations, contradictions, superseded_by
`;

function toRecallResult(entry: StoredEntry, now: Date): RecallResult {
  const breakdown = scoreEntryWithBreakdown(entry, 1, false, now);
  return {
    entry,
    score: breakdown.score,
    scores: breakdown.scores,
  };
}

type ContextCategory = "core" | "recent" | "active" | "preferences";

function classifyContextCategory(entry: StoredEntry): ContextCategory {
  if (entry.expiry === "core") {
    return "core";
  }
  if (entry.type === "todo") {
    return "active";
  }
  if (entry.type === "preference" || entry.type === "decision") {
    return "preferences";
  }
  return "recent";
}

function formatContextMarkdown(refreshedAt: string, entries: StoredEntry[]): string {
  const grouped: Record<ContextCategory, StoredEntry[]> = {
    core: [],
    recent: [],
    active: [],
    preferences: [],
  };
  for (const entry of entries) {
    grouped[classifyContextCategory(entry)].push(entry);
  }

  const lines: string[] = [
    "# Agenr Context",
    "<!-- Generated by agenr context | DO NOT EDIT -->",
    `<!-- refreshed: ${refreshedAt} -->`,
    "",
  ];
  const sections: Array<{ title: string; key: ContextCategory }> = [
    { title: "Core", key: "core" },
    { title: "Recent", key: "recent" },
    { title: "Active", key: "active" },
    { title: "Preferences", key: "preferences" },
  ];

  for (const section of sections) {
    const items = grouped[section.key];
    if (items.length === 0) {
      continue;
    }
    lines.push(`## ${section.title}`);
    for (const item of items) {
      lines.push(`- [${item.type}] ${item.subject}: ${truncateContextContent(item.content)}`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

function selectWithinTokenBudget(results: RecallResult[], tokenBudget: number, maxEntries: number): StoredEntry[] {
  const selected: StoredEntry[] = [];
  let used = 0;

  for (const result of results) {
    if (selected.length >= maxEntries) {
      break;
    }
    const tokens = estimateEntryTokens(result);
    // Keep top-scored entries contiguous: stop at first over-budget item once budget has started.
    if (selected.length > 0 && used + tokens > tokenBudget) {
      break;
    }
    selected.push(result.entry);
    used += tokens;
  }

  return selected;
}

export async function writeContextVariants(
  db: ReturnType<typeof getDb>,
  contextPath: string,
  now: Date,
): Promise<void> {
  const refreshedAt = now.toISOString();
  const contextDir = path.dirname(contextPath);
  const miniPath = path.join(contextDir, "context-mini.md");
  const hotPath = path.join(contextDir, "context-hot.md");

  const allRows = await db.execute({
    sql: `
      SELECT
${ENTRY_SELECT_COLUMNS}
      FROM entries
      WHERE superseded_by IS NULL
      ORDER BY updated_at DESC
      LIMIT 500
    `,
    args: [],
  });

  const scored = allRows.rows
    .map((row) => mapStoredEntry(row, []))
    .map((entry) => toRecallResult(entry, now))
    .sort((a, b) => b.score - a.score);
  const miniEntries = selectWithinTokenBudget(scored, 500, 20);
  await fs.writeFile(miniPath, formatContextMarkdown(refreshedAt, miniEntries), "utf8");

  const tenMinutesAgoIso = new Date(now.getTime() - 10 * 60 * 1000).toISOString();
  const hotRows = await db.execute({
    sql: `
      SELECT
${ENTRY_SELECT_COLUMNS}
      FROM entries
      WHERE superseded_by IS NULL
        AND importance >= 7
        AND updated_at >= ?
      ORDER BY updated_at DESC
      LIMIT 200
    `,
    args: [tenMinutesAgoIso],
  });

  const hotScored = hotRows.rows
    .map((row) => mapStoredEntry(row, []))
    .map((entry) => toRecallResult(entry, now))
    .sort((a, b) => b.score - a.score);
  if (hotScored.length === 0) {
    await fs.writeFile(hotPath, "", "utf8");
    return;
  }

  const hotEntries = selectWithinTokenBudget(hotScored, 200, 200);
  await fs.writeFile(hotPath, formatContextMarkdown(refreshedAt, hotEntries), "utf8");
}

export interface WatchCommandOptions extends WatchOptions {
  interval?: number | string;
  minChunk?: number | string;
}

export interface WatchCommandDeps {
  readConfigFn: typeof readConfig;
  resolveEmbeddingApiKeyFn: typeof resolveEmbeddingApiKey;
  parseTranscriptFileFn: typeof parseTranscriptFile;
  createLlmClientFn: typeof createLlmClient;
  extractKnowledgeFromChunksFn: typeof extractKnowledgeFromChunks;
  deduplicateEntriesFn: typeof deduplicateEntries;
  getDbFn: typeof getDb;
  initDbFn: typeof initDb;
  closeDbFn: typeof closeDb;
  storeEntriesFn: typeof storeEntries;
  loadWatchStateFn: typeof loadWatchState;
  saveWatchStateFn: typeof saveWatchState;
  statFileFn: typeof fs.stat;
  readFileFn: (path: string, offset: number) => Promise<Buffer>;
  generateContextFileFn: typeof generateContextFile;
  nowFn: () => Date;
}

export interface WatchCommandResult {
  exitCode: number;
  cycles: number;
  entriesStored: number;
  durationMs: number;
}

type WatchMode = "file" | "dir";

interface WatchModeConfig {
  mode: WatchMode;
  filePath: string | null;
  sessionsDir: string | null;
  platform: WatchPlatform | null;
  resolver: ReturnType<typeof getResolver> | null;
  warnings: string[];
}

async function resolveWatchMode(
  file: string | undefined,
  options: WatchCommandOptions,
  statFileFn: typeof fs.stat,
): Promise<WatchModeConfig> {
  const hasFile = typeof file === "string" && file.trim().length > 0;
  const hasDir = typeof options.dir === "string" && options.dir.trim().length > 0;
  const autoMode = options.auto === true;
  const hasPlatform = typeof options.platform === "string" && options.platform.trim().length > 0;

  const warnings: string[] = [];
  let effectivePlatform = options.platform;

  if (autoMode) {
    warnings.push(
      "Warning: --auto is deprecated. Use --platform <name> instead. --auto will be removed in a future version.",
    );

    if (!hasPlatform) {
      effectivePlatform = "openclaw";
      warnings.push(
        "Defaulting to --platform openclaw. Specify --platform explicitly to suppress this warning.",
      );
    }
  }

  if (hasFile && hasDir) {
    throw new Error("Choose exactly one watch mode: <file> OR --dir <path> OR --platform <name>.");
  }

  if (hasFile) {
    const filePath = path.resolve((file ?? "").trim());
    const stat = await statFileFn(filePath).catch((error: unknown) => {
      if ((error as NodeJS.ErrnoException).code === "ENOENT") {
        throw new Error(`Transcript file not found: ${filePath}`);
      }
      throw error;
    });

    if (!stat.isFile()) {
      throw new Error(`Input is not a file: ${filePath}`);
    }

    const platform = detectWatchPlatform(effectivePlatform, filePath);
    return {
      mode: "file",
      filePath,
      sessionsDir: null,
      platform,
      resolver: null,
      warnings,
    };
  }

  // Directory mode: explicit --dir, or implicit via --platform defaults.
  let sessionsDir: string | null = null;
  if (hasDir) {
    sessionsDir = path.resolve(options.dir!.trim());
  } else if (typeof effectivePlatform === "string" && effectivePlatform.trim().length > 0) {
    const platform = detectWatchPlatform(effectivePlatform, undefined);
    if (platform === "mtime") {
      throw new Error("--platform mtime requires --dir <path>.");
    }
    sessionsDir = path.resolve(getDefaultPlatformDir(platform));
  }

  if (!sessionsDir) {
    throw new Error("Choose exactly one watch mode: <file> OR --dir <path> OR --platform <name>.");
  }

  const stat = await statFileFn(sessionsDir).catch((error: unknown) => {
    if ((error as NodeJS.ErrnoException).code === "ENOENT") {
      if (!hasDir && typeof effectivePlatform === "string" && effectivePlatform.trim().length > 0) {
        const platform = detectWatchPlatform(effectivePlatform, undefined);
        if (platform !== "mtime") {
          throw new Error(`Platform directory not found: ${sessionsDir}. Is ${platform} installed?`);
        }
      }
      throw new Error(`Sessions directory not found: ${sessionsDir}`);
    }
    throw error;
  });

  if (!stat.isDirectory()) {
    throw new Error(`Input is not a directory: ${sessionsDir}`);
  }

  const platform = detectWatchPlatform(effectivePlatform, sessionsDir);
  const resolver = getResolver(effectivePlatform, sessionsDir);
  const resolvedFile = await resolver.resolveActiveSession(sessionsDir).catch(() => null);

  return {
    mode: "dir",
    filePath: resolvedFile ? path.resolve(resolvedFile) : null,
    sessionsDir,
    platform,
    resolver,
    warnings,
  };
}

export async function runWatchCommand(
  file: string | undefined,
  options: WatchCommandOptions,
  deps?: Partial<WatchCommandDeps>,
): Promise<WatchCommandResult> {
  warnIfLocked();
  installSignalHandlers();

  const resolvedDeps: WatchCommandDeps = {
    readConfigFn: deps?.readConfigFn ?? readConfig,
    resolveEmbeddingApiKeyFn: deps?.resolveEmbeddingApiKeyFn ?? resolveEmbeddingApiKey,
    parseTranscriptFileFn: deps?.parseTranscriptFileFn ?? parseTranscriptFile,
    createLlmClientFn: deps?.createLlmClientFn ?? createLlmClient,
    extractKnowledgeFromChunksFn: deps?.extractKnowledgeFromChunksFn ?? extractKnowledgeFromChunks,
    deduplicateEntriesFn: deps?.deduplicateEntriesFn ?? deduplicateEntries,
    getDbFn: deps?.getDbFn ?? getDb,
    initDbFn: deps?.initDbFn ?? initDb,
    closeDbFn: deps?.closeDbFn ?? closeDb,
    storeEntriesFn: deps?.storeEntriesFn ?? storeEntries,
    loadWatchStateFn: deps?.loadWatchStateFn ?? loadWatchState,
    saveWatchStateFn: deps?.saveWatchStateFn ?? saveWatchState,
    statFileFn: deps?.statFileFn ?? fs.stat,
    readFileFn: deps?.readFileFn ?? readFileFromOffset,
    generateContextFileFn: deps?.generateContextFileFn ?? generateContextFile,
    nowFn: deps?.nowFn ?? (() => new Date()),
  };

  const intervalMs = parsePositiveInt(options.interval, 300, "--interval") * 1000;
  const minChunkChars = parsePositiveInt(options.minChunk, 2000, "--min-chunk");
  const dryRun = options.dryRun === true;
  const verbose = options.verbose === true;
  const once = options.once === true;
  const json = options.json === true;
  const raw = options.raw === true;

  const modeConfig = await resolveWatchMode(file, options, resolvedDeps.statFileFn);

  const clackOutput = { output: process.stderr };
  clack.intro(banner(), clackOutput);

  for (const warning of modeConfig.warnings) {
    process.stderr.write(`${warning}\n`);
  }

  let stateWarning: string | null = null;
  let state = await resolvedDeps.loadWatchStateFn().catch((error: unknown) => {
    stateWarning = `State file is invalid (${error instanceof Error ? error.message : String(error)}). Resetting.`;
    return { version: 1 as const, files: {} };
  });
  if (stateWarning) {
    clack.log.warn(formatWarn(stateWarning), clackOutput);
    await resolvedDeps.saveWatchStateFn(state);
  }

  const fileState = modeConfig.filePath ? getFileState(state, modeConfig.filePath) : undefined;
  const offset = fileState?.byteOffset ?? 0;
  const config = resolvedDeps.readConfigFn(process.env);
  const dbPath = options.db?.trim() || config?.db?.path || "~/.agenr/knowledge.db";

  if (modeConfig.mode === "file") {
    clack.log.info(formatLabel("Watching", modeConfig.filePath ?? "(unknown)"), clackOutput);
  } else if (modeConfig.mode === "dir") {
    clack.log.info(formatLabel("Watching directory", modeConfig.sessionsDir ?? "(unknown)"), clackOutput);
    clack.log.info(formatLabel("Platform", modeConfig.platform ?? "mtime"), clackOutput);
    clack.log.info(
      formatLabel("Active file", modeConfig.filePath ? formatSwitchLabel(modeConfig.filePath) : "(waiting for session file)"),
      clackOutput,
    );
  }

  clack.log.info(
    `${formatLabel("Interval", formatInterval(intervalMs))} | ${formatLabel("Min chunk", `${minChunkChars} chars`)}`,
    clackOutput,
  );
  clack.log.info(
    `${formatLabel("Offset", `${formatBytes(offset)} bytes (${fileState ? "resume" : "fresh"})`)} | ${formatLabel("DB", dbPath)}`,
    clackOutput,
  );
  clack.log.info("", clackOutput);
  clack.log.info("Waiting for changes...", clackOutput);

  let cycleCount = 0;
  let contextChain: Promise<void> = Promise.resolve();
  const summary = await runWatcher(
      {
        filePath: modeConfig.filePath ?? undefined,
        directoryMode: modeConfig.mode === "dir",
        sessionsDir: modeConfig.sessionsDir ?? undefined,
        resolver: modeConfig.resolver ?? undefined,
        platform: modeConfig.platform ?? undefined,
        intervalMs,
        minChunkChars,
        dryRun,
        verbose,
        raw,
        once,
        onlineDedup: options.onlineDedup !== false,
        model: options.model,
        provider: options.provider,
        dbPath: options.db,
        initialState: state,
        onWarn: (message) => {
          if (message.startsWith("Filtered:")) {
            clack.log.info(message, clackOutput);
            return;
          }
          clack.log.warn(formatWarn(message), clackOutput);
        },
        onSwitch: (from, to, platform) => {
          const fromLabel = from ? formatSwitchLabel(from) : "(none)";
          const platformLabel = platform ? ` [${platform}]` : "";
          clack.log.info(`Switched watch file${platformLabel}: ${fromLabel} -> ${formatSwitchLabel(to)}`, clackOutput);
        },
        onCycle: (result, ctx) => {
          cycleCount += 1;
          const timestamp = formatClock(resolvedDeps.nowFn());
          const fileLabel = result.filePath ? ` | file=${result.filePath}` : "";

          if (json) {
            process.stdout.write(`${JSON.stringify({ cycle: cycleCount, at: resolvedDeps.nowFn().toISOString(), ...result })}\n`);
          }

          if (result.error) {
            clack.log.warn(formatWarn(`[${timestamp}] Cycle ${cycleCount}: ${result.error}${fileLabel}`), clackOutput);
            return;
          }

          if (result.skipped) {
            if (result.bytesRead > 0) {
              clack.log.info(
                `[${timestamp}] Cycle ${cycleCount}: +${formatBytes(result.bytesRead)} bytes (below threshold, skipping)${fileLabel}`,
                clackOutput,
              );
            } else if (once || verbose) {
              clack.log.info(`[${timestamp}] Cycle ${cycleCount}: no new content${fileLabel}`, clackOutput);
            }
            return;
          }

          if (dryRun) {
            clack.log.info(
              `[${timestamp}] Cycle ${cycleCount}: +${formatBytes(result.bytesRead)} bytes | ${result.entriesExtracted} entries extracted (dry-run)${fileLabel}`,
              clackOutput,
            );
            return;
          }

          const deduped = Math.max(0, result.entriesExtracted - result.entriesStored);
          clack.log.info(
            `[${timestamp}] Cycle ${cycleCount}: +${formatBytes(result.bytesRead)} bytes | ${result.entriesExtracted} entries extracted | ${result.entriesStored} stored, ${deduped} deduped${fileLabel}`,
            clackOutput,
          );

          if (!dryRun && options.context && result.entriesStored > 0 && ctx.db) {
            const contextPath = path.resolve(options.context.replace(/^~(?=$|\/)/, os.homedir()));
            contextChain = contextChain
              .then(async () => {
                await resolvedDeps.generateContextFileFn(
                  ctx.db!,
                  ctx.apiKey,
                  contextPath,
                  { budget: 2000, limit: 10, json: false },
                );
                await writeContextVariants(ctx.db!, contextPath, resolvedDeps.nowFn());
              })
              .catch((err: unknown) => {
                if (verbose) {
                  clack.log.warn(
                    `Context refresh failed: ${err instanceof Error ? err.message : String(err)}`,
                    clackOutput,
                  );
                }
              });
          }
        },
      },
      {
        readConfigFn: resolvedDeps.readConfigFn,
        resolveEmbeddingApiKeyFn: resolvedDeps.resolveEmbeddingApiKeyFn,
        parseTranscriptFileFn: resolvedDeps.parseTranscriptFileFn,
        createLlmClientFn: resolvedDeps.createLlmClientFn,
        extractKnowledgeFromChunksFn: resolvedDeps.extractKnowledgeFromChunksFn,
        deduplicateEntriesFn: resolvedDeps.deduplicateEntriesFn,
        getDbFn: resolvedDeps.getDbFn,
        initDbFn: resolvedDeps.initDbFn,
        closeDbFn: resolvedDeps.closeDbFn,
        storeEntriesFn: resolvedDeps.storeEntriesFn,
        loadWatchStateFn: resolvedDeps.loadWatchStateFn,
        saveWatchStateFn: resolvedDeps.saveWatchStateFn,
        statFileFn: resolvedDeps.statFileFn,
        readFileFn: resolvedDeps.readFileFn,
        nowFn: resolvedDeps.nowFn,
        shouldShutdownFn: isShutdownRequested,
      },
    );

  // Best-effort: ensure any in-flight context refresh finishes before printing the final summary.
  await contextChain.catch(() => undefined);

  clack.log.info(
    `Summary: ${summary.cycles} cycles | ${summary.entriesStored} entries stored | watched for ${formatDuration(summary.durationMs)}`,
    clackOutput,
  );
  clack.outro(undefined, clackOutput);

  return {
    exitCode: 0,
    cycles: summary.cycles,
    entriesStored: summary.entriesStored,
    durationMs: summary.durationMs,
  };
}
